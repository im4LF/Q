h1. Q3 

Simple database abstraction library for php

h2. Connect to database

bc. require 'path/to/Q/Q.php';
QF('mysql://user:pass@host/dbname') // setup dsn
    ->connect()                     // connect to database
    ->alias('default')              // set "default" alias
    ->tablePrefix('project__');     // set table prefix

Connect to other db and set alias "other-db"

bc. QF('mysql://user:pass@host/dbname2?charset=utf8')->alias('other-db')->connect()->tablePrefix('bb__');

h2. Executing query, fetch row and free result

Execute query, fetch first row and free result

bc. $res = Q('SELECT * FROM #users WHERE id = ?i', array(1));
$row = $res->row();

Builded query:

bc. SELECT * FROM project__users WHERE id = 1

Execute query and fetch each rows. When all rows will be fetched - result will be freeing automatically

bc. $res = Q('SELECT * FROM #users');
while ($row = $res->each())
{
    print_r($row);
}

Execute query, get all rows and free result

bc. $all = Q('SELECT * FROM #users WHERE id > ?i AND id < ?i', array(0, 30))->all();
// get all rows, key in result array will be field ID
$all = Q('SELECT * FROM #users WHERE id > ?i AND id < ?i', array(0, 30))->all('id');

Builded query:

bc. SELECT * FROM project__users WHERE id > 0 AND id < 30

Insert set of data by using one template

bc. Q('INSERT INTO #test VALUES (?i, ?s, ?x, ?e)
        ON DUPLICATE KEY UPDATE a = VALUES(a)*?x', array(
    array(10, 'str11', 'str12', 'a*10'),
    array(20, 'str21', 'str22', 'a*20'),
    50,
    array(30, 'str31', 'str32', 'a*30')
));

Builded query:

bc. INSERT INTO project__test VALUES 
        (10, 'str11', 'str12', a*10), 
        (10, 'str21', 'str22', a*20), 
        (10, 'str31', 'str32', a*30)
    ON DUPLICATE KEY UPDATE
        a = VALUES(a)*50

Where:
?i - integer
?f - float
?b - boolean
?d - date
?t - time
?dt - datetime
?s - string (mysql_real_escape_string)
?x - auto detect type
?e - eval - no changes

Execute query on other db, get all rows and free result

bc. $all = Q('other-db: SHOW TABLES')->all();

You can use connection as a variable

bc. $db = QF('mysql://user:pass@host/dbname?charset=utf8')->connect()->tablePrefix('aa__');
$all = $db->query('SELECT * FROM #registration_document_types')->all();

h2. Aliases for query parameters

You can use aliases for query parameters:

bc. Q('SELECT * FROM #table WHERE a = ?s:param1 AND b = ?i:param2', array(
        'param2' => 123,
        'param1' => 'some value'
);

Builded query:

bc. SELECT * FROM #table WHERE a = 'some value' AND b = 123

Also you can use combined method of passing parameters:

bc. Q('SELECT * FROM #table WHERE a = ?s:param1 AND b = ?i:param2 AND c = ?f', array(
        'param2' => 123,
        12.65,
        'param1' => 'some value'
);

Builded query (if aliases not set, the parameter will be getting by array_shift):

bc. SELECT * FROM #table WHERE a = 'some value' AND b = 123 AND c = 12.65

Another example:

bc. Q('INSERT INTO #table (a, b, c) VALUES 
                (?i:field_a, ?s:field_b, CONCAT(?x, ":", ?s:field_b))
        ON DUPLICATE KEY UPDATE a = VALUES(a) * ?x:multiplier', array(
    array(
        'field_a' => '1', 'field_b' => 'AAA 1', 1
    ),
    array(
        'field_a' => '2', 'field_b' => 'BBB 2', 2
    ),
    'multiplier' => 75,
    array(
        'field_a' => '3', 'field_b' => 'CCC 3', 3
    )
));

Builded query:

bc. INSERT INTO seg__table (a, b, c) VALUES 
        (1, 'AAA 1', CONCAT(1, ":", 'AAA 1')), 
        (2, 'BBB 2', CONCAT(2, ":", 'BBB 2')), 
        (3, 'CCC 3', CONCAT(3, ":", 'CCC 3'))
    ON DUPLICATE KEY UPDATE 
        a = VALUES(a) * 75

h2. Data segmentation

For example you have large amount of data. For example its a table of users.
You can define segmentation rule by which you want to separate data at segments.
For example you dicede separate data by first letter of username: Anna, Amy, Alice ... will be stored in @#users_a@, Bob, Brian ... - @#users_b@ etc.

bc. // segmentation function get table name and query params
function tableSeg($table, &$query_params)
{
    if ('table' != $table)
        return $table;
    return '_'.strtolower($query_params['name']{0});
}

Now you must define segmentation function by @tableSegmentationFunc@ method:

bc. QF('mysql://user:pass@localhost/test?charset=utf8')
    ->alias('default')
    ->tablePrefix('seg__')
    ->tableSegmentationFunc('tableSeg'); 

And now all queries like this will separate data:

bc. Q('INSERT INTO #users/s VALUES(NULL, ?s:name, ?s:param1, ?s:param2)', array(
    'name' => 'Alice',
    'param1' => mt_rand(),
    'param2' => mt_rand()
));

Builded query:

bc. INSERT INTO seg__users_a VALUES(NULL, 'Alice', '191376831', '333672130')

Also you can separate data between different database servers. 
You must define segmentaion function and several connections:

bc. function dsnSeg(&$query_params)
{
    $dsn = 'default'; 
    if (preg_match('/[a-e]/i', $query_params['name']{0}))
        $dsn = 'table_ae';
    elseif (preg_match('/[f-j]/i', $query_params['name']{0}))
        $dsn = 'table_fj';
    return $dsn;
}

bc. QF('mysql://user1:pass1@seg_ae/db?charset=utf8', 'dsnSeg')->alias('seg_ae')->tablePrefix('project__');
QF('mysql://user2:pass2@seg_fj/db?charset=utf8', 'dsnSeg')->alias('seg_fj')->tablePrefix('project__');

And now queries like this will separate data beetween different server:

bc. Q('*: INSERT INTO #users VALUES(NULL, ?s:name, ?s:param1, ?s:param2)', array(
    'name' => 'Fry',
    'param1' => mt_rand(),
    'param2' => mt_rand()
));

Query will be executed on @seg_fj@ connection.

h2. Lazy connection

When you creating new database object by factory @QF@ you may not open connection by @connect@ method. The connection will be opened with first query.

bc. QF('mysql://user:pass@localhost/test?charset=utf8')->alias('default')->tablePrefix('prefix__');
// connection not opened
...
Q('SELECT * FROM #some_table WHERE param1 = 123');
// connection opened and query executed
...
Q('SELECT * FROM #some_table WHERE param1 = 321');
// query executed on previously opened connection
